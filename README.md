### Word Ladders with 1 edit Distance transitions

A simple BFS search implementation of a precomputed search tree to find word chains from start word to goal word. The constraint being that a transition can only add / remove / replace a single letter of the word.

My approach does a simple breadth first search on a graph generated by calculating all possible transitions for each word in the wordlist.txt file. In case of no solution, no output is returned.

The transitions for each word are precomputed and stored in `data/transitions.json`. In order to discard invalid transitions, and not just brute force search over all permutations of 1 character add or delete, the Levenshtein distance is used. A valid transition has a distance of 1 while also being present in the wordlist. The transition generation takes about 12-14 mins on my  `Intel(R) Core(TM) i5-6200U CPU @ 2.30GHz` , taking `~700 mb` of RAM.

BFS is implemented with a queue(LinkedList from standard Java library.) Anagrams are handled by storing the transitions in a hashmap. Altough, there is no definite order as to which anagram is displayed in the final output(Pass -all to see all possible words). Sorted letters of the word is used as a hash key. Worstcase runtime is 1.7 - 2 seconds on my laptop.

### Usage

`BFS.jar <start word> <goal word> [--all]`

`--all` lists all possible transitions.


References:

https://en.wikipedia.org/wiki/Levenshtein_distance  

https://en.wikipedia.org/wiki/Wagnerâ€“Fischer_algorithm




